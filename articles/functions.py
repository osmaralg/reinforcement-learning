# -*- coding: utf-8 -*-
"""project_EMEC.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11KiW2eJptlMiX4M6ZeyAJocT0RRBSsUS
"""

# %%

import numpy as np
#import sys
#sys.path.append('c:/users/mahit/appdata/local/packages/pythonsoftwarefoundation.python.3.8_qbz5n2kfra8p0/localcache/local-packages/python38/site-packages')
import tensorflow as tf
import pandas as pd
import random
import json

# %%

# Load the model

# %%


economy = 0  # Daily economic transaction

#Inputs
s = 200 #size of the grid
N = 1000 #size of population
M = round(N * 0.007) #Number of infectious population
Et = 2 #Number of days staying exposed
It = 21 #Number of days staying infectious
Mt = 8 #Number of daily movements
D = 100 #Number of days
death_rate = 100
expose_rate = 10

# Initialization
S = N - M  # Susceptible population
E = 0  # Exposed population
I = M  # Number of infectious population
R = 0  # Recovered population
P = S + E + I + R  # Total population
economy = 0  # Daily economic transaction


# %%

# Create a virtual environment actions
def init_state():  # init

    global P, M, It, s
    dummy_array = np.zeros(shape=(P, 8))
    df = pd.DataFrame(dummy_array, columns=['x', 'y', 'Day', 'Susceptible', 'Exposed', 'Infectious', 'Recovered', 'GG'])
    df = df.astype(
        {'x': int, 'y': int, 'Day': int, 'Susceptible': bool, 'Exposed': int, 'Infectious': int, 'Recovered': bool,
         'GG': bool})
    df['Susceptible'] = True
    # Appending infectious population in
    dfupdate = df.sample(M)
    dfupdate['Infectious'] = np.random.randint(1, It, size=len(dfupdate))
    dfupdate['Susceptible'] = False
    df.update(dfupdate)
    update_list = dfupdate.index.tolist()
    # Dispersing people randomly among grid
    df['x'] = np.random.randint(0, s, size=len(df))
    df['y'] = np.random.randint(0, s, size=len(df))

    return df

def load_model(path):
    from tensorflow import keras
    return keras.models.load_model(path)

def one_day(df, action=0):
    # start_time = time.time()
    global P, M, It, S, death_rate, expose_rate
    policy_match = {0: 1, 1: 0.75, 2: 0.25}  # assign action to policy
    moves_under_policy = int(round(Mt * policy_match[action], 0))

    df_infectious = df.loc[(df['Infectious'] > 0)]
    df_infectious = df_infectious[['x', 'y']]

    for mt in range(moves_under_policy):
        for index, person in df.iterrows():

            if not person['GG']:  # If the person is not dead

                new_move_x = random.choice(range(-1, 2))
                new_move_y = random.choice(range(-1, 2))

                person['x'] = max(min(person['x'] + new_move_x, s), 0)
                person['y'] = max(min(person['y'] + new_move_y, s), 0)

                df.iat[index, 0] = int(person['x'])
                df.iat[index, 1] = int(person['y'])

                if index in df_infectious.index:  # assigning whats in person (row) to df_infectious at the correct index
                    df_infectious.at[index, 'x'] = person['x']
                    df_infectious.at[index, 'y'] = person['y']

                if (person['Infectious'] > 0) and (person['Recovered'] == False):  # If a person is in infectious state
                    if person['Infectious'] - random.choice(range(0, 7)) >= It:  # If the infectious days are completed
                        if random.choice(range(0, death_rate)) > (
                                death_rate - 2):  # If the person dies(with probability distribution 1:4)
                            df.at[index, 'Infectious'] = 0
                            if index in df_infectious.index:
                                df_infectious.drop([index])

                            df.at[index, 'GG'] = True  # Kill the person
                        else:  # If the person survives
                            df.at[index, 'Infectious'] = 0
                            if index in df_infectious.index:
                                df_infectious.drop([index])
                            df.at[index, 'Recovered'] = True  # Recover the person
                    elif mt + 1 == moves_under_policy:
                        if person['Infectious'] == 0.5:
                            df.at[index, 'Infectious'] = 1
                        else:
                            df.at[index, 'Infectious'] = person['Infectious'] + 1  # Increase the infectious day counter


                        # print(f'No. {index} infected {person.Infectious} in day {d} at {mt}')


                elif person['Exposed'] > 0:  # If a person is in exposed state

                    if (person['Exposed'] - random.choice(range(0, 10))) >= Et:  # If the person has reached the exposed day limit?  7
                        #print(f'*When No. {index} infected, Exposure is {person.Exposed} in day {d} at move {mt}')

                        df.at[index, 'Exposed'] = 0
                        df.at[index, 'Infectious'] = 0.5 if mt+1 != moves_under_policy else 1  # Increase the infectious day counter, now the person is infectious
                        df_infectious.append(person)
                    elif mt + 1 == moves_under_policy: # At the end of the day
                        if person['Exposed'] == 0.5:
                            df.at[index, 'Exposed'] = 1
                        else:
                            df.at[index, 'Exposed'] = person['Exposed'] + 1  # Increase the exposed day counter

                        #print(f'No. {index} exposure increased to {df.at[index, "Exposed"]} in day {d} at {mt}')


                elif person['Susceptible']:  # If the person is in susceptible state

                    x_temp = int(person['x'])
                    df_xtemp = df_infectious[['x']].to_numpy()

                    if (x_temp in df_xtemp) or ((x_temp - 1) in df_xtemp) or ((x_temp + 1) in df_xtemp):

                        y_temp = int(person['y'])
                        df_ytemp = df_infectious[['y']].to_numpy()
                        if (y_temp in df_ytemp) or ((y_temp - 1) in df_ytemp) or ((y_temp + 1) in df_ytemp):
                            if random.choice(range(0, expose_rate)) > (expose_rate - 2):
                                df.at[index, 'Exposed'] = 0.5 if mt+1 != moves_under_policy else 1
                                df.at[index, 'Susceptible'] = False

    return df  # time.time() - start_time #


def economy_gain(df):
    economy_gain = len(df[(df.GG == False) & (df.Infectious == 0)]) * round(random.uniform(0.8, 1), 2)
    return economy_gain


def current_state(df):
    global economy
    active_cases = len(df.loc[df['Infectious'] > 0])
    new_inf = len(df.loc[df['Infectious'] == 1])
    recovered = len(df.loc[df['Recovered'] == True])
    gg = len(df.loc[df['GG'] == True])
    reproduction_rate = len(df.loc[df['Infectious'] == 1]) / len(df.loc[df['Infectious'] > 1]) if len(df.loc[df['Infectious'] > 1]) > 0 else 0
    economy = economy + economy_gain(df)

    return np.array([active_cases, new_inf, recovered, gg, reproduction_rate, economy])

def health_state(df):
    global economy
    active_cases = df['Infectious'].values[0]
    recovered = len(df.loc[df['Recovered'] == True])
    gg = len(df.loc[df['GG'] == True])
    sus = len(df.loc[df['Susceptible'] == True])
    
    return np.array([active_cases, recovered, gg, sus])


def rule(df):
    row = df.to_frame()
    row_t = row.T
    state = health_state(row_t)    
    if state[2] > 0:
        return "dead"
    elif state[0] == 0:
        return "healthy"
    elif state[3] > 0:
        return "susceptible"
    elif state[0] > 1:
        return "infectious"
    elif state[0] == 1:
        return "newly infected" 
               
    else:
        return "none"

# %%

def create_scatter_plot(df_total, reward, action):
    status = ["healthy", "dead", "infectious", "susceptible", "newly infected"]
    df_total['Status'] = df_total.apply(lambda x: rule(x), axis=1)
    daily_status = df_total[['x', 'y', 'Day', 'Status']].copy(deep=True).reset_index()
    daily_status["Position"] = list(zip(daily_status['x'], daily_status['y']))
    daily_status.rename(columns={"index": "Person"}, inplace=True)
    complete_status = []
    for i, x in daily_status.to_dict('index').items():
        complete_status.append(x)
        for stat in status:
            if stat not in daily_status.at[i, "Status"]:
                complete_status.append({"Position": None, "Status": stat, "Day": daily_status.at[i, "Day"],
                                        "Person": daily_status.at[i, "Person"]}) #code to fill in missing positions
    complete_status_df = pd.DataFrame(complete_status)
    complete_status_df.Position = complete_status_df.Position.apply(lambda x: list(x) if type(x) == tuple else x)
    complete_status_df.sort_values(['Day', 'Person'], ascending=[True, True], inplace=True)
    # complete_status_df.to_excel('output1.xlsx')
   
    scatterplot = complete_status_df.groupby(['Day', 'Status'], as_index=False)['Position'].apply(list).to_frame()
    scatterplot_dict = {level: scatterplot.xs(level).to_dict('index') for level in scatterplot.index.levels[0]}
    # for every day and every person and every status we need an entry
    for key in scatterplot_dict:
        scatterplot_dict[key]["susceptible"] = scatterplot_dict[key]["susceptible"][0]
        scatterplot_dict[key]["infectious"] = scatterplot_dict[key]["infectious"][0]
        scatterplot_dict[key]["total_susceptible"] = (
            sum(x is not None for x in scatterplot_dict[key]["susceptible"]))
        scatterplot_dict[key]["reward"] = int(reward[key])
        scatterplot_dict[key]["action"] = int(action[key])
        scatterplot_dict[key]["total_dead"] = (
            sum(x is not None for x in scatterplot_dict[key]["dead"][0]))        
        scatterplot_dict[key]["total_infectious"] = (
            sum(x is not None for x in scatterplot_dict[key]["infectious"])) 
        scatterplot_dict[key]["total_newly_infected"] = (
            sum(x is not None for x in scatterplot_dict[key]["newly infected"][0]))
        scatterplot_dict[key]["total_healthy"] = (sum(x is not None for x in scatterplot_dict[key]["healthy"][0]))
    
    for key in scatterplot_dict:
        if "healthy" in scatterplot_dict[key]:
            del [scatterplot_dict[key]["healthy"]] 
        if "dead" in scatterplot_dict[key]: 
            del [scatterplot_dict[key]["dead"]]
        if "newly infected" in scatterplot_dict[key]:
            del [scatterplot_dict[key]["newly infected"]] 
        if "none" in scatterplot_dict[key]:
            del [scatterplot_dict[key]["none"]] 

    return scatterplot_dict



def simulate(df=init_state(), current_day=0):
    # Use the agent to make decisions
    #import tensorflow as tf
    economy = 0
    model = load_model("model_ann_3layer2.pb")
    state = current_state(df)
    state = tf.reshape(state, [1, 6])
    prediction = model.predict(state, steps=1)
    action_by_agent = np.argmax(prediction)
    df = one_day(df, action=action_by_agent)
    gain = economy_gain(df)
    economy += gain
    #print(f"Day {current_day + 1}: take action {action_by_agent}, total_reward: {economy}. {prediction}")
    plot_dict = create_scatter_plot(df, gain, action_by_agent)
    return plot_dict

def calculate_reward_action(tf, model, df=init_state()):
    # calculate reward and action

    #model = load_model("model_ann_3layer")
    economy = 0
    state = current_state(df)
    state = tf.reshape(state, [1, 6])
    prediction = model.predict(state, steps=1)
    action_by_agent = np.argmax(prediction)
    df = one_day(df, action=action_by_agent)
    gain = economy_gain(df)
    economy += gain
    return df, gain, action_by_agent

